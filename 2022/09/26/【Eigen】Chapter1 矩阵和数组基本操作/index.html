<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>【Eigen】Chapter1 矩阵和数组基本操作 Dense Matrix And Arrary | 风吹花舞う</title><meta name="keywords" content="矩阵"><meta name="author" content="风吹花舞う"><meta name="copyright" content="风吹花舞う"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="（0）模块和头文件    模块 头文件 内容     Core #include &lt;Eigen&#x2F;Core&gt; 矩阵和数组类，基本线性代数，数组操作   Geometry #include &lt;Eigen&#x2F;Geometry&gt; 变换、平移、缩放、2D旋转 和 3D 旋转（四元数、AngleAxis）   LU #include &lt;Eigen&#x2F;LU&gt; 使用求解器求方阵的逆">
<meta property="og:type" content="article">
<meta property="og:title" content="【Eigen】Chapter1 矩阵和数组基本操作 Dense Matrix And Arrary">
<meta property="og:url" content="http://example.com/2022/09/26/%E3%80%90Eigen%E3%80%91Chapter1%20%E7%9F%A9%E9%98%B5%E5%92%8C%E6%95%B0%E7%BB%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/index.html">
<meta property="og:site_name" content="风吹花舞う">
<meta property="og:description" content="（0）模块和头文件    模块 头文件 内容     Core #include &lt;Eigen&#x2F;Core&gt; 矩阵和数组类，基本线性代数，数组操作   Geometry #include &lt;Eigen&#x2F;Geometry&gt; 变换、平移、缩放、2D旋转 和 3D 旋转（四元数、AngleAxis）   LU #include &lt;Eigen&#x2F;LU&gt; 使用求解器求方阵的逆">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/sakura.jpg">
<meta property="article:published_time" content="2022-09-26T12:42:34.000Z">
<meta property="article:modified_time" content="2022-09-29T06:49:03.480Z">
<meta property="article:author" content="风吹花舞う">
<meta property="article:tag" content="矩阵">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/sakura.jpg"><link rel="shortcut icon" href="/img/rokisi.jpg"><link rel="canonical" href="http://example.com/2022/09/26/%E3%80%90Eigen%E3%80%91Chapter1%20%E7%9F%A9%E9%98%B5%E5%92%8C%E6%95%B0%E7%BB%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【Eigen】Chapter1 矩阵和数组基本操作 Dense Matrix And Arrary',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-29 14:49:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/rokisi.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/SLAM/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 专栏</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-diamond"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-edit"></i><span> 动态</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fa fa-image"></i><span> 图库</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fa fa-video"></i><span> 动画</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/sakura.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">风吹花舞う</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 专栏</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-diamond"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-edit"></i><span> 动态</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fa fa-image"></i><span> 图库</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fa fa-video"></i><span> 动画</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【Eigen】Chapter1 矩阵和数组基本操作 Dense Matrix And Arrary</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-26T12:42:34.000Z" title="发表于 2022-09-26 20:42:34">2022-09-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-29T06:49:03.480Z" title="更新于 2022-09-29 14:49:03">2022-09-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/SLAM/SLAM/">SLAM</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/SLAM/SLAM/Eigen/">Eigen</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【Eigen】Chapter1 矩阵和数组基本操作 Dense Matrix And Arrary"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="（0）模块和头文件"><a href="#（0）模块和头文件" class="headerlink" title="（0）模块和头文件"></a>（0）模块和头文件</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">模块</th>
<th style="text-align:center">头文件</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Core</td>
<td style="text-align:center"><code>#include &lt;Eigen/Core&gt;</code></td>
<td style="text-align:center">矩阵和数组类，基本线性代数，数组操作</td>
</tr>
<tr>
<td style="text-align:center">Geometry</td>
<td style="text-align:center"><code>#include &lt;Eigen/Geometry&gt;</code></td>
<td style="text-align:center">变换、平移、缩放、2D旋转 和 3D 旋转（四元数、AngleAxis）</td>
</tr>
<tr>
<td style="text-align:center">LU</td>
<td style="text-align:center"><code>#include &lt;Eigen/LU&gt;</code></td>
<td style="text-align:center">使用求解器求方阵的逆与行列式，以及对矩阵进行 LU 分解 (FullPivLU, PartialPivLU)</td>
</tr>
<tr>
<td style="text-align:center">Cholesky</td>
<td style="text-align:center"><code>#include &lt;Eigen/Cholesky&gt;</code></td>
<td style="text-align:center">使用求解器进行 LLT 和 LDLT Cholesky 分解</td>
</tr>
<tr>
<td style="text-align:center">Householder</td>
<td style="text-align:center"><code>#include &lt;Eigen/Householder&gt;</code></td>
<td style="text-align:center">Householder transformations; this module is used by several linear algebra modules</td>
</tr>
<tr>
<td style="text-align:center">SVD</td>
<td style="text-align:center"><code>#include &lt;Eigen/SVD&gt;</code></td>
<td style="text-align:center">使用最小二乘求解器进行 SVD 分解（JacobiSVD、BDCSVD）</td>
</tr>
<tr>
<td style="text-align:center">QR</td>
<td style="text-align:center"><code>#include &lt;Eigen/QR&gt;</code></td>
<td style="text-align:center">使用求解器进行 QR 分解（HouseholderQR、ColPivHouseholderQR、FullPivHouseholderQR）</td>
</tr>
<tr>
<td style="text-align:center">Eigenvalues</td>
<td style="text-align:center"><code>#include &lt;Eigen/Eigenvalues&gt;</code></td>
<td style="text-align:center">特征值、特征向量分解（EigenSolver、SelfAdjointEigenSolver、ComplexEigenSolver）</td>
</tr>
<tr>
<td style="text-align:center">Sparse</td>
<td style="text-align:center"><code>#include &lt;Eigen/Sparse&gt;</code></td>
<td style="text-align:center">稀疏矩阵存储及相关基础线性代数（SparseMatrix、SparseVector）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><code>#include &lt;Eigen/Dense&gt;</code></td>
<td style="text-align:center">包括 Core、Geometry、LU、Cholesky、SVD、QR 和 Eigenvalues 头文件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"><code>#include &lt;Eigen/Eigen&gt;</code></td>
<td style="text-align:center">包括 Dense 和 Sparse 头文件（整个 Eigen 库）</td>
</tr>
</tbody>
</table>
</div>
<h4 id="（1）矩阵类"><a href="#（1）矩阵类" class="headerlink" title="（1）矩阵类"></a>（1）矩阵类</h4><p>​    1）Matrix&lt;&gt;模板类定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Matrix&lt;<span class="keyword">typename</span> Scalar, <span class="type">int</span> RowsAtCompileTime, <span class="type">int</span> ColsAtCompileTime&gt;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">typedef</span> Matrix&lt;<span class="type">double</span>, Dynamic, Dynamic&gt; MatrixXd;</span><br><span class="line"><span class="keyword">typedef</span> Matrix&lt;<span class="type">int</span>, Dynamic, <span class="number">1</span>&gt; VectorXi;</span><br><span class="line"><span class="keyword">typedef</span> Matrix&lt;<span class="type">float</span>, <span class="number">3</span>, <span class="number">1</span>&gt; Vector3f;</span><br><span class="line"><span class="keyword">typedef</span> Matrix&lt;<span class="type">float</span>, <span class="number">4</span>, <span class="number">4</span>&gt; Matrix4f;</span><br></pre></td></tr></table></figure>
<p>​    2）构造</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Matrix3f a;		<span class="comment">//3*3</span></span><br><span class="line">MatrixXf b;		</span><br><span class="line"></span><br><span class="line"><span class="function">MatrixXf <span class="title">a</span><span class="params">(<span class="number">10</span>,<span class="number">15</span>)</span></span>;	<span class="comment">//10*15</span></span><br><span class="line"><span class="function">VectorXf <span class="title">b</span><span class="params">(<span class="number">30</span>)</span></span>;		<span class="comment">//30*1</span></span><br></pre></td></tr></table></figure>
<p>​    固定大小的向量提供了初始化操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector2d <span class="title">a</span><span class="params">(<span class="number">5.0</span>, <span class="number">6.0</span>)</span></span>;</span><br><span class="line"><span class="function">Vector3d <span class="title">b</span><span class="params">(<span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>)</span></span>;</span><br><span class="line"><span class="function">Vector4d <span class="title">c</span><span class="params">(<span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>​    定义矩阵大小，但未初始化,该方式在堆上分配内存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MatrixXd <span class="title">m</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span>;	<span class="comment">//2*2的矩阵</span></span><br><span class="line"><span class="comment">// 矩阵元素赋值，index 从0开始</span></span><br><span class="line"><span class="built_in">m</span>(<span class="number">0</span>, <span class="number">0</span>) = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">1</span>, <span class="number">0</span>) = <span class="number">2.5</span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">0</span>, <span class="number">1</span>) = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">1</span>, <span class="number">1</span>) = <span class="built_in">m</span>(<span class="number">1</span>, <span class="number">0</span>) + <span class="built_in">m</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>​    矩阵和矢量系数可以使用所谓的逗号初始化语法方便地设置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Matrix3f m;</span><br><span class="line">m &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line"> 	<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">	<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MatrixXi a &#123;      <span class="comment">// construct a 2x2 matrix</span></span><br><span class="line">      &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,     <span class="comment">// first row</span></span><br><span class="line">      &#123;<span class="number">3</span>, <span class="number">4</span>&#125;      <span class="comment">// second row</span></span><br><span class="line">&#125;;</span><br><span class="line">Matrix&lt;<span class="type">double</span>, <span class="number">2</span>, <span class="number">3</span>&gt; b &#123;</span><br><span class="line">      &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">      &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​    3）动态调整</p>
<p>​    不能调整固定大小的矩阵的大小</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MatrixXd <span class="title">m</span><span class="params">(<span class="number">2</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">m.<span class="built_in">resize</span>(<span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The matrix m is of size &quot;</span></span><br><span class="line">          &lt;&lt; m.<span class="built_in">rows</span>() &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; m.<span class="built_in">cols</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;It has &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; coefficients&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="function">VectorXd <span class="title">v</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The vector v is of size &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;As a matrix, v is of size &quot;</span></span><br><span class="line">          &lt;&lt; v.<span class="built_in">rows</span>() &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; v.<span class="built_in">cols</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// Output is:</span></span><br><span class="line"><span class="comment">// The matrix m is of size 4x3</span></span><br><span class="line"><span class="comment">// It has 12 coefficients</span></span><br><span class="line"><span class="comment">// The vector v is of size 5</span></span><br><span class="line"><span class="comment">// As a matrix, v is of size 5x1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//operator= 将矩阵复制到另一个矩阵中的操作。Eigen自动调整左侧矩阵的大小，使其与右侧大小的矩阵大小匹配。例如：</span></span><br><span class="line"><span class="function">MatrixXf <span class="title">a</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a is of size &quot;</span> &lt;&lt; a.<span class="built_in">rows</span>() &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; a.<span class="built_in">cols</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="function">MatrixXf <span class="title">b</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">a = b;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a is now of size &quot;</span> &lt;&lt; a.<span class="built_in">rows</span>() &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; a.<span class="built_in">cols</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">//a is of size 2x2</span></span><br><span class="line"><span class="comment">//a is now of size 3x3</span></span><br></pre></td></tr></table></figure>
<p>​    4）固定尺寸与动态尺寸</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 固定大小的矩阵or向量在栈上分配内存，因为它在编译时期就可以确定大小</span></span><br><span class="line"><span class="comment">// Matrix4f mymatrix  ≈  float mymatrix[16];</span></span><br><span class="line"><span class="comment">// MatrixX表示运行时才确定矩阵的大小，因为它在堆上分配内存</span></span><br><span class="line"><span class="comment">// MatrixXf mymatrix(rows,columns) ≈  float *mymatrix = new float[rows*columns];</span></span><br><span class="line">MatrixXd m = MatrixXd::<span class="built_in">Random</span>(<span class="number">3</span>, <span class="number">3</span>);          <span class="comment">//  random values between -1 and 1</span></span><br><span class="line">m = (m + MatrixXd::<span class="built_in">Constant</span>(<span class="number">3</span>, <span class="number">3</span>, <span class="number">1.2</span>)) * <span class="number">50</span>; <span class="comment">// MatrixXd::Constant(3, 3, 1.2) represents a 3-by-3 matrix expression having all coefficients equal to 1.2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m =&quot;</span> &lt;&lt; endl</span><br><span class="line">     &lt;&lt; m &lt;&lt; endl;</span><br><span class="line"><span class="function">VectorXd <span class="title">v</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// 尚未初始化</span></span><br><span class="line">v &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;  <span class="comment">//  uses the so-called comma-initializer</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m * v =&quot;</span> &lt;&lt; endl</span><br><span class="line">     &lt;&lt; m * v &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>​    什么时候应该使用固定尺寸（例如Matrix4f），什么时候应该使用动态尺寸（例如MatrixXf）？</p>
<p>​        简单的答案是：在可能的地方使用固定尺寸来显示非常小的尺寸，在需要的地方使用动态尺寸来显示较大的尺寸。</p>
<p>​        对于小尺寸，尤其是对于小于（大约）16的尺寸，使用固定尺寸对性能有极大的好处，因为它使Eigen避免了动态内存分配并展开了循环。</p>
<p>​        在内部，固定大小的本征矩阵只是一个简单的数组，即 <code>Matrix4f mymatrix;</code>真的等于只是在做 <code>float[16];</code> 因此这确实具有零运行时间成本。相比之下，动态大小矩阵的数组始终分配在堆上，因此 <code>MatrixXf mymatrix（行，列）;</code>等于做 <code>float * mymatrix = new [行*列];</code>除此之外，MatrixXf对象还将其行数和列数存储为成员变量。当然，使用固定大小的限制是，只有当您在编译时知道大小时，才有可能这样做。同样，对于足够大的尺寸（例如，对于大于（大约）32的尺寸），使用固定尺寸的性能优势变得可以忽略不计。更糟糕的是，尝试使用函数内部的固定大小创建非常大的矩阵可能会导致堆栈溢出，因为Eigen会尝试自动将数组分配为局部变量，而这通常是在堆栈上完成的。最后，视情况而定，当使用动态尺寸时，Eigen还可尝试进行矢量化（使用SIMD指令），请参见参考矢量化。</p>
<p>​    5）可选模板参数</p>
<p>​    在页面开始时提到Matrix类采用六个模板参数，但到目前为止，我们仅讨论了前三个。其余三个参数是可选的。这是模板参数的完整列表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Matrix&lt;<span class="keyword">typename</span> Scalar,</span><br><span class="line">       <span class="type">int</span> RowsAtCompileTime,</span><br><span class="line">       <span class="type">int</span> ColsAtCompileTime,</span><br><span class="line">       <span class="type">int</span> Options = <span class="number">0</span>,</span><br><span class="line">       <span class="type">int</span> MaxRowsAtCompileTime = RowsAtCompileTime,</span><br><span class="line">       <span class="type">int</span> MaxColsAtCompileTime = ColsAtCompileTime&gt;</span><br></pre></td></tr></table></figure>
<p>​    Options是位字段。在这里，我们只讨论一点：RowMajor。它指定这种类型的矩阵使用行优先存储顺序。默认情况下，存储顺序为“按列的顺序存储”。例如，此类型表示行优先存储的3x3矩阵：<code>Matrix&lt;float，3、3，RowMajor&gt;</code><br>​    MaxRowsAtCompileTime并且MaxColsAtCompileTime在您希望指定时很有用，即使在编译时不知道矩阵的确切大小，在编译时也知道固定的上限。可能要这样做的最大原因是避免动态内存分配。例如，以下矩阵类型使用12个浮点数的普通数组，而不分配动态内存：<br><code>Matrix&lt;float，Dynamic，Dynamic，0、3、4&gt;</code></p>
<p>​    6）Matrix typedef</p>
<p>​    MatrixNt for <code>Matrix&lt;type, N, N&gt;</code> For example, <code>MatrixXi for Matrix&lt;int, Dynamic, Dynamic&gt;</code><br>​    VectorNt for <code>Matrix&lt;type, N, 1&gt;</code> For example, <code>Vector2f for Matrix&lt;float, 2, 1&gt;</code><br>​    RowVectorNt for <code>Matrix&lt;type, 1, N&gt;</code> For example, <code>RowVector3d for Matrix&lt;double, 1, 3&gt;</code></p>
<p>​    其中：</p>
<p>​        N可以是任何一个2，3，4，或X（意思Dynamic）。</p>
<p>​       t可以是i（表示int），f（表示float），d（表示double），cf（表示complex <float>）或cd（表示complex <double>）的任何一种。</p>
<p>​        仅针对这五个类型定义typedef的事实并不意味着它们是唯一受支持的标量类型。例如，支持所有标准整数类型，请参阅标量类型。</p>
<h4 id="（2）矩阵与向量运算"><a href="#（2）矩阵与向量运算" class="headerlink" title="（2）矩阵与向量运算"></a>（2）矩阵与向量运算</h4><p>​    1）加减运算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Eigen::Matrix2d a;</span><br><span class="line">  a &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">       <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line">  <span class="function">Eigen::MatrixXd <span class="title">b</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">  b &lt;&lt; <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">       <span class="number">1</span>, <span class="number">4</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;a + b =\n&quot;</span> &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;a - b =\n&quot;</span> &lt;&lt; a - b &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Doing a += b;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  a += b;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Now a =\n&quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">  <span class="function">Eigen::Vector3d <span class="title">v</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">  <span class="function">Eigen::Vector3d <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;-v + w - v =\n&quot;</span> &lt;&lt; -v + w - v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    2）标量乘法除法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Eigen::Matrix2d a;</span><br><span class="line">  a &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">       <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line">  <span class="function">Eigen::Vector3d <span class="title">v</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;a * 2.5 =\n&quot;</span> &lt;&lt; a * <span class="number">2.5</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;0.1 * v =\n&quot;</span> &lt;&lt; <span class="number">0.1</span> * v &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Doing v *= 2;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  v *= <span class="number">2</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Now v =\n&quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    3）转置和共轭</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MatrixXcf a = MatrixXcf::<span class="built_in">Random</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is the matrix a\n&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is the matrix a^T\n&quot;</span> &lt;&lt; a.<span class="built_in">transpose</span>() &lt;&lt; endl;		<span class="comment">//转置矩阵</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is the conjugate of a\n&quot;</span> &lt;&lt; a.<span class="built_in">conjugate</span>() &lt;&lt; endl;	<span class="comment">//共轭矩阵</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is the matrix a^*\n&quot;</span> &lt;&lt; a.<span class="built_in">adjoint</span>() &lt;&lt; endl;			<span class="comment">//伴随矩阵</span></span><br></pre></td></tr></table></figure>
<p>​    注意：对于一个矩阵自身的转置，应该使用.transposeInPlace()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Matrix2i a; a &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is the matrix a:\n&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="comment">//错误做法</span></span><br><span class="line">a = a.<span class="built_in">transpose</span>(); <span class="comment">// !!! do NOT do this !!!</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;and the result of the aliasing effect:\n&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="comment">//正确做法</span></span><br><span class="line"><span class="function">MatrixXf <span class="title">a</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>; </span><br><span class="line">a &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is the initial matrix a:\n&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">a.<span class="built_in">transposeInPlace</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;and after being transposed:\n&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>​    4）矩阵乘法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Eigen::Matrix2d mat;</span><br><span class="line">  mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">         <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line">  <span class="function">Eigen::Vector2d <span class="title">u</span><span class="params">(<span class="number">-1</span>,<span class="number">1</span>)</span>, <span class="title">v</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Here is mat*mat:\n&quot;</span> &lt;&lt; mat*mat &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Here is mat*u:\n&quot;</span> &lt;&lt; mat*u &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Here is u^T*mat:\n&quot;</span> &lt;&lt; u.<span class="built_in">transpose</span>()*mat &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Here is u^T*v:\n&quot;</span> &lt;&lt; u.<span class="built_in">transpose</span>()*v &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Here is u*v^T:\n&quot;</span> &lt;&lt; u*v.<span class="built_in">transpose</span>() &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Let&#x27;s multiply mat by itself&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  mat = mat*mat;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Now mat is mat:\n&quot;</span> &lt;&lt; mat &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    5）点乘和叉乘</p>
<p>​    叉积只适用于大小为3的向量，点积适用于任意向量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Eigen::Vector3d <span class="title">v</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">  <span class="function">Eigen::Vector3d <span class="title">w</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Dot product: &quot;</span> &lt;&lt; v.<span class="built_in">dot</span>(w) &lt;&lt; std::endl;</span><br><span class="line">  <span class="type">double</span> dp = v.<span class="built_in">adjoint</span>()*w; <span class="comment">// automatic conversion of the inner product to a scalar</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Dot product via a matrix product: &quot;</span> &lt;&lt; dp &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Cross product:\n&quot;</span> &lt;&lt; v.<span class="built_in">cross</span>(w) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    6）基本算术操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Eigen::Matrix2d mat;</span><br><span class="line">  mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">         <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Here is mat.sum():       &quot;</span> &lt;&lt; mat.<span class="built_in">sum</span>()       &lt;&lt; endl;		<span class="comment">//元素和</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Here is mat.prod():      &quot;</span> &lt;&lt; mat.<span class="built_in">prod</span>()      &lt;&lt; endl;		<span class="comment">//元素乘积</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Here is mat.mean():      &quot;</span> &lt;&lt; mat.<span class="built_in">mean</span>()      &lt;&lt; endl;		<span class="comment">//元素均值</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Here is mat.minCoeff():  &quot;</span> &lt;&lt; mat.<span class="built_in">minCoeff</span>()  &lt;&lt; endl;		<span class="comment">//最小系数</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Here is mat.maxCoeff():  &quot;</span> &lt;&lt; mat.<span class="built_in">maxCoeff</span>()  &lt;&lt; endl;		<span class="comment">//最大系数</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Here is mat.trace():     &quot;</span> &lt;&lt; mat.<span class="built_in">trace</span>()     &lt;&lt; endl;		<span class="comment">//迹</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    可以输出元素位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Matrix3f m = Matrix3f::<span class="built_in">Random</span>();</span><br><span class="line">std::<span class="type">ptrdiff_t</span> i, j;</span><br><span class="line"><span class="type">float</span> minOfM = m.<span class="built_in">minCoeff</span>(&amp;i,&amp;j);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is the matrix m:\n&quot;</span> &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Its minimum coefficient (&quot;</span> &lt;&lt; minOfM </span><br><span class="line">     &lt;&lt; <span class="string">&quot;) is at position (&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;)\n\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">RowVector4i v = RowVector4i::<span class="built_in">Random</span>();</span><br><span class="line"><span class="type">int</span> maxOfV = v.<span class="built_in">maxCoeff</span>(&amp;i);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is the vector v: &quot;</span> &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Its maximum coefficient (&quot;</span> &lt;&lt; maxOfV </span><br><span class="line">     &lt;&lt; <span class="string">&quot;) is at position &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h4 id="（3）Array类与系数操作"><a href="#（3）Array类与系数操作" class="headerlink" title="（3）Array类与系数操作"></a>（3）Array类与系数操作</h4><p>​    1）Array</p>
<p>​    与用于线性代数的Matrix类相反，Array类提供了通用数组。此外，Array类提供了一种执行逐系数运算的简便方法，该运算可能没有线性代数含义，例如将常数添加到数组中的每个系数或按系数乘两个数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array&lt;<span class="keyword">typename</span> Scalar, <span class="type">int</span> RowsAtCompileTime, <span class="type">int</span> ColsAtCompileTime&gt;</span><br></pre></td></tr></table></figure>
<p>​    Eigen还为某些常见情况提供了typedef，其方式类似于Matrix typedef，但有一些细微的差异，因为单词 “array”既用于一维数组，也用于二维数组。</p>
<p>​    一维数组采用ArrayNt形式的typedef代表，其中N和t是大小和标量类型</p>
<p>​    二维数组采用ArrayNNt形式的typedef</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Array&lt;<span class="type">float</span>,Dynamic,<span class="number">1</span>&gt; 			<span class="comment">//ArrayXf </span></span><br><span class="line">Array&lt;<span class="type">float</span>,<span class="number">3</span>,<span class="number">1</span>&gt; 				<span class="comment">//Array3f </span></span><br><span class="line">Array&lt;<span class="type">double</span>,Dynamic,Dynamic&gt; 	<span class="comment">//ArrayXXd </span></span><br><span class="line">Array&lt;<span class="type">double</span>,<span class="number">3</span>,<span class="number">3</span>&gt; 				<span class="comment">//Array33d </span></span><br></pre></td></tr></table></figure>
<p>​    2）访问数组中的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Eigen::ArrayXXf  <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// assign some values coefficient by coefficient</span></span><br><span class="line">  <span class="built_in">m</span>(<span class="number">0</span>,<span class="number">0</span>) = <span class="number">1.0</span>; <span class="built_in">m</span>(<span class="number">0</span>,<span class="number">1</span>) = <span class="number">2.0</span>;</span><br><span class="line">  <span class="built_in">m</span>(<span class="number">1</span>,<span class="number">0</span>) = <span class="number">3.0</span>; <span class="built_in">m</span>(<span class="number">1</span>,<span class="number">1</span>) = <span class="built_in">m</span>(<span class="number">0</span>,<span class="number">1</span>) + <span class="built_in">m</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// print values to standard output</span></span><br><span class="line">  std::cout &lt;&lt; m &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// using the comma-initializer is also allowed</span></span><br><span class="line">  m &lt;&lt; <span class="number">1.0</span>,<span class="number">2.0</span>,</span><br><span class="line">       <span class="number">3.0</span>,<span class="number">4.0</span>;</span><br><span class="line">     </span><br><span class="line">  <span class="comment">// print values to standard output</span></span><br><span class="line">  std::cout &lt;&lt; m &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    3）加减法</p>
<p>​    两个数组的加减法与矩阵相同。如果两个数组的大小相同，并且该加法或减法是按系数进行的，则此操作有效。数组还支持以下形式的表达式，该表达式array + scalar将标量添加到数组中的每个系数。这提供了不能直接用于Matrix对象的功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Eigen::ArrayXXf <span class="title">a</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">  <span class="function">Eigen::ArrayXXf <span class="title">b</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">  a &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,</span><br><span class="line">       <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,</span><br><span class="line">       <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>;</span><br><span class="line">  b &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,</span><br><span class="line">       <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,</span><br><span class="line">       <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;</span><br><span class="line">       </span><br><span class="line">  <span class="comment">// Adding two arrays</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;a + b = &quot;</span> &lt;&lt; std::endl &lt;&lt; a + b &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Subtracting a scalar from an array</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;a - 2 = &quot;</span> &lt;&lt; std::endl &lt;&lt; a - <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    4）数组乘法</p>
<p>​    矩阵将乘法解释为矩阵乘积，而数组将乘法解释为按系数乘积</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Eigen::ArrayXXf <span class="title">a</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">  <span class="function">Eigen::ArrayXXf <span class="title">b</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">  a &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">       <span class="number">3</span>,<span class="number">4</span>;</span><br><span class="line">  b &lt;&lt; <span class="number">5</span>,<span class="number">6</span>,</span><br><span class="line">       <span class="number">7</span>,<span class="number">8</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;a * b = &quot;</span> &lt;&lt; std::endl &lt;&lt; a * b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output is:</span></span><br><span class="line"><span class="comment">// a * b =</span></span><br><span class="line"><span class="comment">//  5 12</span></span><br><span class="line"><span class="comment">//  21 32</span></span><br></pre></td></tr></table></figure>
<p>​    5） 其他运算      </p>
<pre><code> 数组类定义除上述加法，减法和乘法运算符其他系数为单位的运算。例如，.abs()方法获取每个系数的绝对值，而.sqrt（）计算系数的平方根。如果有两个大小相同的数组，则可以调用.min()来构造其系数是两个给定数组中对应系数的最小值的数组。注意:.array()和.matrix() 转换为相同的维数，但是不同的对象具有不同的方法
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Eigen::ArrayXf a = Eigen::ArrayXf::<span class="built_in">Random</span>(<span class="number">5</span>);</span><br><span class="line">  a *= <span class="number">2</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;a =&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;a.abs() =&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; a.<span class="built_in">abs</span>() &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;a.abs().sqrt() =&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; a.<span class="built_in">abs</span>().<span class="built_in">sqrt</span>() &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;a.min(a.abs().sqrt()) =&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; a.<span class="built_in">min</span>(a.<span class="built_in">abs</span>().<span class="built_in">sqrt</span>()) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output is:</span></span><br><span class="line"><span class="comment">// a =</span></span><br><span class="line"><span class="comment">//   1.36</span></span><br><span class="line"><span class="comment">// -0.422</span></span><br><span class="line"><span class="comment">//   1.13</span></span><br><span class="line"><span class="comment">//   1.19</span></span><br><span class="line"><span class="comment">//   1.65</span></span><br><span class="line"><span class="comment">// a.abs() =</span></span><br><span class="line"><span class="comment">//  1.36</span></span><br><span class="line"><span class="comment">// 0.422</span></span><br><span class="line"><span class="comment">//  1.13</span></span><br><span class="line"><span class="comment">//  1.19</span></span><br><span class="line"><span class="comment">//  1.65</span></span><br><span class="line"><span class="comment">// a.abs().sqrt() =</span></span><br><span class="line"><span class="comment">// 1.17</span></span><br><span class="line"><span class="comment">// 0.65</span></span><br><span class="line"><span class="comment">// 1.06</span></span><br><span class="line"><span class="comment">// 1.09</span></span><br><span class="line"><span class="comment">// 1.28</span></span><br><span class="line"><span class="comment">// a.min(a.abs().sqrt()) =</span></span><br><span class="line"><span class="comment">//   1.17</span></span><br><span class="line"><span class="comment">// -0.422</span></span><br><span class="line"><span class="comment">//   1.06</span></span><br><span class="line"><span class="comment">//   1.09</span></span><br><span class="line"><span class="comment">//   1.28</span></span><br></pre></td></tr></table></figure>
<p>​    6）数组与矩阵之间的转换</p>
<p>​    什么时候应该使用Matrix类的对象，什么时候应该使用Array类的对象？</p>
<p>​    简单来说，不能对数组应用矩阵运算，也不能对矩阵应用数组运算。因此，如果需要进行线性代数运算（例如矩阵乘法），则应使用矩阵。如果需要进行系数运算，则应使用数组。但是，有时并不是那么简单，但是您需要同时使用Matrix和Array操作。在这种情况下，需要将矩阵转换为数组或反向转换。无论选择将对象声明为数组还是矩阵，都可以访问所有操作。</p>
<p>​    矩阵表达式具有.array()方法，可以将它们“转换”为数组表达式，因此可以轻松地应用按系数进行运算。相反，数组表达式具有.matrix()方法。与所有Eigen表达式抽象一样，这没有任何运行时开销（只要您让编译器进行优化）.array（）和.matrix() 可被用作右值和作为左值。</p>
<p>​    Eigen禁止在表达式中混合矩阵和数组。 例如，不能直接矩阵和数组相加。运算符+的操作数要么都是矩阵，要么都是数组。但是，使用.array（）和.matrix（）可以轻松地将其转换为另一种。注意，此规则的例外是赋值运算符=：允许将矩阵表达式分配给数组变量，或将数组表达式分配给矩阵变量。下面的示例演示如何通过使用.array（）方法对Matrix对象使用数组操作。</p>
<p>​     例如，语句需要两个矩阵和，他们两个转换为阵列，用来将它们相乘系数明智并将结果指定给矩阵变量（这是合法的，因为本征允许分配数组表达式到矩阵的变量）。result = m.array() * n.array()mnresult。实际上，这种使用情况非常普遍，以至于Eigen为矩阵提供了const .cwiseProduct()方法来计算系数乘积。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> Eigen::MatrixXf;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">MatrixXf <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">  <span class="function">MatrixXf <span class="title">n</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">  <span class="function">MatrixXf <span class="title">result</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">  m &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">       <span class="number">3</span>,<span class="number">4</span>;</span><br><span class="line">  n &lt;&lt; <span class="number">5</span>,<span class="number">6</span>,</span><br><span class="line">       <span class="number">7</span>,<span class="number">8</span>;</span><br><span class="line"> </span><br><span class="line">  result = m * n;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;-- Matrix m*n: --\n&quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">  result = m.<span class="built_in">array</span>() * n.<span class="built_in">array</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;-- Array m*n: --\n&quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">  result = m.<span class="built_in">cwiseProduct</span>(n);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;-- With cwiseProduct: --\n&quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">  result = m.<span class="built_in">array</span>() + <span class="number">4</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;-- Array m + 4: --\n&quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output is:</span></span><br><span class="line"><span class="comment">// -- Matrix m*n: --</span></span><br><span class="line"><span class="comment">// 19 22</span></span><br><span class="line"><span class="comment">// 43 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -- Array m*n: --</span></span><br><span class="line"><span class="comment">//  5 12</span></span><br><span class="line"><span class="comment">// 21 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -- With cwiseProduct: --</span></span><br><span class="line"><span class="comment">//  5 12</span></span><br><span class="line"><span class="comment">// 21 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -- Array m + 4: --</span></span><br><span class="line"><span class="comment">// 5 6</span></span><br><span class="line"><span class="comment">// 7 8</span></span><br></pre></td></tr></table></figure>
<h4 id="（4）块操作"><a href="#（4）块操作" class="headerlink" title="（4）块操作"></a>（4）块操作</h4><p>​    1）使用块</p>
<p>​    块是矩阵或数组的某一部分。块表达式既可以用作右值，也可以用作左值。</p>
<p>​    <code>Block of size (p,q), starting at (i,j)</code></p>
<p>​    1 起始位置+行列数 <code>matrix.block(i,j,p,q);</code></p>
<p>​    2 模板参数为行列数，函数参数为起始位置 <code>matrix.block&lt;p,q&gt;(i,j);</code></p>
<p>​    两种版本均可用于固定大小和动态大小的矩阵和数组。这两个表达式在语义上是等效的。唯一的区别是，如果块大小较小，则固定大小版本通常会为您提供更快的代码，但是需要在编译时知道此大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Eigen::MatrixXf <span class="title">m</span><span class="params">(<span class="number">4</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">  m &lt;&lt;  <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">        <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>,</span><br><span class="line">        <span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,</span><br><span class="line">       <span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Block in the middle&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; m.<span class="built_in">block</span>&lt;<span class="number">2</span>,<span class="number">2</span>&gt;(<span class="number">1</span>,<span class="number">1</span>) &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Block of size &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;x&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">block</span>(<span class="number">0</span>,<span class="number">0</span>,i,i) &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Eigen::Array22f m;</span><br><span class="line">  m &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">       <span class="number">3</span>,<span class="number">4</span>;</span><br><span class="line">  Eigen::Array44f a = Eigen::Array44f::<span class="built_in">Constant</span>(<span class="number">0.6</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Here is the array a:\n&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">  a.<span class="built_in">block</span>&lt;<span class="number">2</span>,<span class="number">2</span>&gt;(<span class="number">1</span>,<span class="number">1</span>) = m;	<span class="comment">//可作为左值</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Here is now a with m copied into its central 2x2 block:\n&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">  a.<span class="built_in">block</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>) = a.<span class="built_in">block</span>(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Here is now a with bottom-right 2x3 block copied into top-left 2x3 block:\n&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    2）列（columns）和行（rows）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Eigen::MatrixXf <span class="title">m</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">  m &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,</span><br><span class="line">       <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,</span><br><span class="line">       <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;2nd Row: &quot;</span> &lt;&lt; m.<span class="built_in">row</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">  m.<span class="built_in">col</span>(<span class="number">2</span>) += <span class="number">3</span> * m.<span class="built_in">col</span>(<span class="number">0</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;After adding 3 times the first column into the third column, the matrix m is:\n&quot;</span>;</span><br><span class="line">  cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    3）一系列矩阵的边角块操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Eigen::Matrix4f m;</span><br><span class="line">  m &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">       <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>,</span><br><span class="line">       <span class="number">9</span>, <span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,</span><br><span class="line">       <span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;m.leftCols(2) =&quot;</span> &lt;&lt; endl &lt;&lt; m.<span class="built_in">leftCols</span>(<span class="number">2</span>) &lt;&lt; endl &lt;&lt; endl;			<span class="comment">//前两列</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;m.bottomRows&lt;2&gt;() =&quot;</span> &lt;&lt; endl &lt;&lt; m.<span class="built_in">bottomRows</span>&lt;<span class="number">2</span>&gt;() &lt;&lt; endl &lt;&lt; endl;	<span class="comment">//下两行</span></span><br><span class="line">  m.<span class="built_in">topLeftCorner</span>(<span class="number">1</span>,<span class="number">3</span>) = m.<span class="built_in">bottomRightCorner</span>(<span class="number">3</span>,<span class="number">1</span>).<span class="built_in">transpose</span>();					</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;After assignment, m = &quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    4）向量的边角块操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Eigen::ArrayXf <span class="title">v</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">  v &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v.head(3) =&quot;</span> &lt;&lt; endl &lt;&lt; v.<span class="built_in">head</span>(<span class="number">3</span>) &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v.tail&lt;3&gt;() = &quot;</span> &lt;&lt; endl &lt;&lt; v.<span class="built_in">tail</span>&lt;<span class="number">3</span>&gt;() &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">  v.<span class="built_in">segment</span>(<span class="number">1</span>,<span class="number">4</span>) *= <span class="number">2</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;after &#x27;v.segment(1,4) *= 2&#x27;, v =&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（5）高级初始化方法"><a href="#（5）高级初始化方法" class="headerlink" title="（5）高级初始化方法"></a>（5）高级初始化方法</h4><p>​    1）逗号初始化器</p>
<p>​        需要预先指定对象的大小。如果列出的系数太少或太多，就会报错。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Matrix3f m;</span><br><span class="line">m &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">     <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">     <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>;</span><br><span class="line">std::cout &lt;&lt; m;</span><br></pre></td></tr></table></figure>
<pre><code>   此外，初始化列表的元素本身可以是向量或矩阵。通常的用途是将向量或矩阵连接在一起。例如，这是将两个行向量连接在一起的方法。 注意：必须先设置大小，然后才能使用逗号初始化程序。
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RowVectorXd <span class="title">vec1</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">vec1 &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;vec1 = &quot;</span> &lt;&lt; vec1 &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line"><span class="function">RowVectorXd <span class="title">vec2</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">vec2 &lt;&lt; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;vec2 = &quot;</span> &lt;&lt; vec2 &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line"><span class="function">RowVectorXd <span class="title">joined</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">joined &lt;&lt; vec1, vec2;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;joined = &quot;</span> &lt;&lt; joined &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>​        类似分块矩阵的初始化方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MatrixXf <span class="title">matA</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">matA &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line"><span class="function">MatrixXf <span class="title">matB</span><span class="params">(<span class="number">4</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">matB &lt;&lt; matA, matA/<span class="number">10</span>, matA/<span class="number">10</span>, matA;</span><br><span class="line">std::cout &lt;&lt; matB &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>​        对矩阵的某一块赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Matrix3f m;</span><br><span class="line">m.<span class="built_in">row</span>(<span class="number">0</span>) &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</span><br><span class="line">m.<span class="built_in">block</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>) &lt;&lt; <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>;</span><br><span class="line">m.<span class="built_in">col</span>(<span class="number">2</span>).<span class="built_in">tail</span>(<span class="number">2</span>) &lt;&lt; <span class="number">6</span>, <span class="number">9</span>;                   </span><br><span class="line">std::cout &lt;&lt; m;</span><br></pre></td></tr></table></figure>
<p>​    2）特殊矩阵和数组</p>
<p>​    模板类Matrix&lt;&gt;和Array&lt;&gt;有静态方法，可以帮助初始化；</p>
<p>​    有三种变体:</p>
<p>​        第一个变体不带参数，只能用于固定大小的对象。如果要将动态尺寸对象初始化为零，则需要指定尺寸。</p>
<p>​        第二个变体需要一个参数，并且可以用于一维动态尺寸对象，</p>
<p>​        第三个变体需要两个参数，并且可以用于二维对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;A fixed-size array:\n&quot;</span>;</span><br><span class="line">Array33f a1 = Array33f::<span class="built_in">Zero</span>();</span><br><span class="line">std::cout &lt;&lt; a1 &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;A one-dimensional dynamic-size array:\n&quot;</span>;</span><br><span class="line">ArrayXf a2 = ArrayXf::<span class="built_in">Zero</span>(<span class="number">3</span>);</span><br><span class="line">std::cout &lt;&lt; a2 &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;A two-dimensional dynamic-size array:\n&quot;</span>;</span><br><span class="line">ArrayXXf a3 = ArrayXXf::<span class="built_in">Zero</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">std::cout &lt;&lt; a3 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line"><span class="comment">//A fixed-size array:</span></span><br><span class="line"><span class="comment">//0 0 0</span></span><br><span class="line"><span class="comment">//0 0 0</span></span><br><span class="line"><span class="comment">//0 0 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//A one-dimensional dynamic-size array:</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//A two-dimensional dynamic-size array:</span></span><br><span class="line"><span class="comment">//0 0 0 0</span></span><br><span class="line"><span class="comment">//0 0 0 0</span></span><br><span class="line"><span class="comment">//0 0 0 0</span></span><br></pre></td></tr></table></figure>
<p>​        同样，静态方法Constant(value)会将所有系数设置为value。如果需要指定对象的大小，则附加参数放在value参数之前，如</p>
<p><code>MatrixXd::Constant(rows, cols, value)</code>。</p>
<p>​        Random()用随机系数填充矩阵或数组。Identity()获得单位矩阵, 此方法仅适用于Matrix，不适用于Array，因为“单位矩阵”是线性代数概念。该方法LinSpaced（尺寸，低，高）是仅可用于载体和一维数组; 它产生一个指定大小的向量，其系数在low和之间平均间隔high。方法LinSpaced()以下示例说明了该示例，该示例打印一张表格，其中包含以度为单位的角度，以弧度为单位的相应角度以及它们的正弦和余弦值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ArrayXXf <span class="title">table</span><span class="params">(<span class="number">10</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">table.<span class="built_in">col</span>(<span class="number">0</span>) = ArrayXf::<span class="built_in">LinSpaced</span>(<span class="number">10</span>, <span class="number">0</span>, <span class="number">90</span>);</span><br><span class="line">table.<span class="built_in">col</span>(<span class="number">1</span>) = M_PI / <span class="number">180</span> * table.<span class="built_in">col</span>(<span class="number">0</span>);</span><br><span class="line">table.<span class="built_in">col</span>(<span class="number">2</span>) = table.<span class="built_in">col</span>(<span class="number">1</span>).<span class="built_in">sin</span>();</span><br><span class="line">table.<span class="built_in">col</span>(<span class="number">3</span>) = table.<span class="built_in">col</span>(<span class="number">1</span>).<span class="built_in">cos</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;  Degrees   Radians      Sine    Cosine\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; table &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>​    Eigen定义了诸如<code>setZero()</code>，<code>MatrixBase :: setIdentity()</code>和<code>DenseBase :: setLinSpaced()</code>之类的实用程序函数来方便地执行此操作。即，可以采用对象的成员函数设置初始值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">6</span>;</span><br><span class="line"><span class="function">MatrixXd <span class="title">mat1</span><span class="params">(size, size)</span></span>;</span><br><span class="line">mat1.<span class="built_in">topLeftCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>)     = MatrixXd::<span class="built_in">Zero</span>(size/<span class="number">2</span>, size/<span class="number">2</span>);</span><br><span class="line">mat1.<span class="built_in">topRightCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>)    = MatrixXd::<span class="built_in">Identity</span>(size/<span class="number">2</span>, size/<span class="number">2</span>);</span><br><span class="line">mat1.<span class="built_in">bottomLeftCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>)  = MatrixXd::<span class="built_in">Identity</span>(size/<span class="number">2</span>, size/<span class="number">2</span>);</span><br><span class="line">mat1.<span class="built_in">bottomRightCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>) = MatrixXd::<span class="built_in">Zero</span>(size/<span class="number">2</span>, size/<span class="number">2</span>);</span><br><span class="line">std::cout &lt;&lt; mat1 &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line"><span class="function">MatrixXd <span class="title">mat2</span><span class="params">(size, size)</span></span>;</span><br><span class="line">mat2.<span class="built_in">topLeftCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>).<span class="built_in">setZero</span>();</span><br><span class="line">mat2.<span class="built_in">topRightCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>).<span class="built_in">setIdentity</span>();</span><br><span class="line">mat2.<span class="built_in">bottomLeftCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>).<span class="built_in">setIdentity</span>();</span><br><span class="line">mat2.<span class="built_in">bottomRightCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>).<span class="built_in">setZero</span>();</span><br><span class="line">std::cout &lt;&lt; mat2 &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line"><span class="function">MatrixXd <span class="title">mat3</span><span class="params">(size, size)</span></span>;</span><br><span class="line">mat3 &lt;&lt; MatrixXd::<span class="built_in">Zero</span>(size/<span class="number">2</span>, size/<span class="number">2</span>), MatrixXd::<span class="built_in">Identity</span>(size/<span class="number">2</span>, size/<span class="number">2</span>),</span><br><span class="line">        MatrixXd::<span class="built_in">Identity</span>(size/<span class="number">2</span>, size/<span class="number">2</span>), MatrixXd::<span class="built_in">Zero</span>(size/<span class="number">2</span>, size/<span class="number">2</span>);</span><br><span class="line">std::cout &lt;&lt; mat3 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h4 id="（6）归约，访问者和广播"><a href="#（6）归约，访问者和广播" class="headerlink" title="（6）归约，访问者和广播"></a>（6）归约，访问者和广播</h4><p>​    1）归约</p>
<p>​    在Eigen中，约简是一个采用矩阵或数组并返回单个标量值的函数。最常用的归约方法之一是<code>.sum()</code>，它返回给定矩阵或数组内所有系数的总和。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Eigen::Matrix2d mat;</span><br><span class="line">  mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">         <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Here is mat.sum():       &quot;</span> &lt;&lt; mat.<span class="built_in">sum</span>()       &lt;&lt; endl;	<span class="comment">//所有元素之和</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Here is mat.prod():      &quot;</span> &lt;&lt; mat.<span class="built_in">prod</span>()      &lt;&lt; endl;	<span class="comment">//所有元素乘积</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Here is mat.mean():      &quot;</span> &lt;&lt; mat.<span class="built_in">mean</span>()      &lt;&lt; endl;	<span class="comment">//和/个数</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Here is mat.minCoeff():  &quot;</span> &lt;&lt; mat.<span class="built_in">minCoeff</span>()  &lt;&lt; endl;	<span class="comment">//最小值</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Here is mat.maxCoeff():  &quot;</span> &lt;&lt; mat.<span class="built_in">maxCoeff</span>()  &lt;&lt; endl;	<span class="comment">//最大值</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Here is mat.trace():     &quot;</span> &lt;&lt; mat.<span class="built_in">trace</span>()     &lt;&lt; endl;	<span class="comment">//迹</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    2）范数计算</p>
<p>​    2范数的平方可以通过s<code>quaredNorm()</code>获得。它本身等于矢量的点积，并且等效于其系数的平方绝对值的总和。<code>norm()</code>方法返回<code>squaredNorm()</code>的平方根。</p>
<p>​    这些运算也可以在矩阵上运算。在这种情况下，n×p矩阵被视为大小（n * p）的向量，因此，例如norm()方法返回“ Frobenius”或“ Hilbert-Schmidt”范数。</p>
<p>​    我们避免谈论l^2矩阵的范数，因为那可能意味着不同的事情。如果需要其他按系数分配的l^p范数，请使用lpNorm <p>()。如果需要无穷范数，则模板参数p可以采用特殊值Infinity，这是系数绝对值的最大值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Eigen::VectorXf <span class="title">v</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">  <span class="function">Eigen::MatrixXf <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span>, <span class="title">n</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">  v &lt;&lt; <span class="number">-1</span>,</span><br><span class="line">       <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  m &lt;&lt; <span class="number">1</span>,<span class="number">-2</span>,</span><br><span class="line">       <span class="number">-3</span>,<span class="number">4</span>;</span><br><span class="line">  <span class="comment">//向量范数</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;v.squaredNorm() = &quot;</span> &lt;&lt; v.<span class="built_in">squaredNorm</span>() &lt;&lt; std::endl;	<span class="comment">//2-范数的平方</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;v.norm() = &quot;</span> &lt;&lt; v.<span class="built_in">norm</span>() &lt;&lt; std::endl;					<span class="comment">//2-范数</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;v.lpNorm&lt;1&gt;() = &quot;</span> &lt;&lt; v.<span class="built_in">lpNorm</span>&lt;<span class="number">1</span>&gt;() &lt;&lt; std::endl;		<span class="comment">//1-范数</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;v.lpNorm&lt;Infinity&gt;() = &quot;</span> &lt;&lt; v.<span class="built_in">lpNorm</span>&lt;Eigen::Infinity&gt;() &lt;&lt; std::endl;	<span class="comment">//无穷范数</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line">  <span class="comment">//矩阵范数</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;m.squaredNorm() = &quot;</span> &lt;&lt; m.<span class="built_in">squaredNorm</span>() &lt;&lt; std::endl;	<span class="comment">//m2-范数的平方</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;m.norm() = &quot;</span> &lt;&lt; m.<span class="built_in">norm</span>() &lt;&lt; std::endl;					<span class="comment">//m2-范数		</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;m.lpNorm&lt;1&gt;() = &quot;</span> &lt;&lt; m.<span class="built_in">lpNorm</span>&lt;<span class="number">1</span>&gt;() &lt;&lt; std::endl;		<span class="comment">//m1-范数</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;m.lpNorm&lt;Infinity&gt;() = &quot;</span> &lt;&lt; m.<span class="built_in">lpNorm</span>&lt;Eigen::Infinity&gt;() &lt;&lt; std::endl;	<span class="comment">//？既不是m无穷范数也不是无穷范数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Eigen::MatrixXf <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">  m &lt;&lt; <span class="number">1</span>,<span class="number">-2</span>,</span><br><span class="line">       <span class="number">-3</span>,<span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;1-norm(m)     = &quot;</span> &lt;&lt; m.<span class="built_in">cwiseAbs</span>().<span class="built_in">colwise</span>().<span class="built_in">sum</span>().<span class="built_in">maxCoeff</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot; == &quot;</span>             &lt;&lt; m.<span class="built_in">colwise</span>().<span class="built_in">lpNorm</span>&lt;<span class="number">1</span>&gt;().<span class="built_in">maxCoeff</span>() &lt;&lt; std::endl;	<span class="comment">//1-范数（列和范数）</span></span><br><span class="line"> </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;infty-norm(m) = &quot;</span> &lt;&lt; m.<span class="built_in">cwiseAbs</span>().<span class="built_in">rowwise</span>().<span class="built_in">sum</span>().<span class="built_in">maxCoeff</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot; == &quot;</span>             &lt;&lt; m.<span class="built_in">rowwise</span>().<span class="built_in">lpNorm</span>&lt;<span class="number">1</span>&gt;().<span class="built_in">maxCoeff</span>() &lt;&lt; std::endl;	<span class="comment">//无穷范数（行和范数）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    3）布尔</p>
<p>​    如果给定 Matrix 或 Array 中的所有系数都为 true ，则 all() 返回 true 。     </p>
<p>​    如果给定 Matrix 或 Array 中的至少一个系数计算结果为 true ，则 any() 返回 true 。   </p>
<p>​    count() 返回给定矩阵或数组中计算结果为真的系数的数量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Eigen::ArrayXXf <span class="title">a</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">  a &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">       <span class="number">3</span>,<span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;(a &gt; 0).all()   = &quot;</span> &lt;&lt; (a &gt; <span class="number">0</span>).<span class="built_in">all</span>() &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;(a &gt; 0).any()   = &quot;</span> &lt;&lt; (a &gt; <span class="number">0</span>).<span class="built_in">any</span>() &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;(a &gt; 0).count() = &quot;</span> &lt;&lt; (a &gt; <span class="number">0</span>).<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;(a &gt; 2).all()   = &quot;</span> &lt;&lt; (a &gt; <span class="number">2</span>).<span class="built_in">all</span>() &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;(a &gt; 2).any()   = &quot;</span> &lt;&lt; (a &gt; <span class="number">2</span>).<span class="built_in">any</span>() &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;(a &gt; 2).count() = &quot;</span> &lt;&lt; (a &gt; <span class="number">2</span>).<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    4）访问者</p>
<p>​    在矩阵和数组的所有元素中，想要获得一个系数在Matrix或Array中的位置时，访问者很有用。最简单的示例是maxCoeff（＆x，＆y）和minCoeff（＆x，＆y），可用于查找Matrix或Array中最大或最小系数的位置。传递给访问者的参数是指向要存储行和列位置的变量的指针。这些变量应为Index类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> &lt;Eigen/Dense</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Eigen::MatrixXf <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">  m &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">       <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//get location of maximum</span></span><br><span class="line">  Eigen::Index maxRow, maxCol;</span><br><span class="line">  <span class="type">float</span> max = m.<span class="built_in">maxCoeff</span>(&amp;maxRow, &amp;maxCol);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//get location of minimum</span></span><br><span class="line">  Eigen::Index minRow, minCol;</span><br><span class="line">  <span class="type">float</span> min = m.<span class="built_in">minCoeff</span>(&amp;minRow, &amp;minCol);</span><br><span class="line"> </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Max: &quot;</span> &lt;&lt; max &lt;&lt;  <span class="string">&quot;, at: &quot;</span> &lt;&lt;</span><br><span class="line">     maxRow &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; maxCol &lt;&lt; std::endl;</span><br><span class="line">  std:: cout &lt;&lt; <span class="string">&quot;Min: &quot;</span> &lt;&lt; min &lt;&lt; <span class="string">&quot;, at: &quot;</span> &lt;&lt;</span><br><span class="line">     minRow &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; minCol &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    5）部分归约</p>
<p>​    在矩阵或数组的列向量和行向量中,element-wise是按元素的，那么colwise()或rowwise()表示按列或行的。部分归约是可以在Matrix或Array上按列或按行操作的归约，对每个列或行应用归约运算并返回具有相应值的列或行向量。部分缩减适用于colwis()或rowwise()</p>
<p>​    一个简单的示例是获取给定矩阵中每一列中元素的最大值，并将结果存储在行向量中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Eigen::MatrixXf <span class="title">mat</span><span class="params">(<span class="number">2</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">  mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>,</span><br><span class="line">         <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Column&#x27;s maximum: &quot;</span> &lt;&lt; std::endl</span><br><span class="line">   &lt;&lt; mat.<span class="built_in">colwise</span>().<span class="built_in">maxCoeff</span>() &lt;&lt; std::endl;		<span class="comment">// 对于矩阵mat的每一列，取最大系数值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Eigen::MatrixXf <span class="title">mat</span><span class="params">(<span class="number">2</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">  mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>,</span><br><span class="line">         <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Row&#x27;s maximum: &quot;</span> &lt;&lt; std::endl</span><br><span class="line">   &lt;&lt; mat.<span class="built_in">rowwise</span>().<span class="built_in">maxCoeff</span>() &lt;&lt; std::endl;		<span class="comment">// 对于矩阵mat的每一行，取最大系数值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    6）部分归约与其他操作结合</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Eigen::MatrixXf <span class="title">mat</span><span class="params">(<span class="number">2</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">  mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>,</span><br><span class="line">         <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  Eigen::Index   maxIndex;</span><br><span class="line">  <span class="type">float</span> maxNorm = mat.<span class="built_in">colwise</span>().<span class="built_in">sum</span>().<span class="built_in">maxCoeff</span>(&amp;maxIndex);		<span class="comment">//对于矩阵的每一列中的元素求和，结果的最大系数在第2列</span></span><br><span class="line">  </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Maximum sum at position &quot;</span> &lt;&lt; maxIndex &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;The corresponding vector is: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; mat.<span class="built_in">col</span>( maxIndex ) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;And its sum is is: &quot;</span> &lt;&lt; maxNorm &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    7）广播</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">	<span class="comment">//广播背后的概念类似于部分归约，区别在于广播构造了一个表达式，其中向量（列或行）通过在一个方向上复制而被解释为矩阵。</span></span><br><span class="line">    <span class="comment">//一个简单的示例是将某个列向量添加到矩阵中的每一列。这可以通过以下方式完成：</span></span><br><span class="line">    <span class="function">Eigen::MatrixXf <span class="title">mat</span><span class="params">(<span class="number">2</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">Eigen::VectorXf <span class="title">v</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>,</span><br><span class="line">           <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>;</span><br><span class="line">    v &lt;&lt; <span class="number">0</span>,</span><br><span class="line">         <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//add v to each column of m</span></span><br><span class="line">    <span class="comment">//mat.colwise() += v用两种等效的方式解释指令。</span></span><br><span class="line">    <span class="comment">//它将向量添加v到矩阵的每一列。或者，可以将其解释为重复向量v四次以形成四乘二矩阵，然后将其加到mat</span></span><br><span class="line">    mat.<span class="built_in">colwise</span>() += v;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Broadcasting result: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; mat &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（7）Map类"><a href="#（7）Map类" class="headerlink" title="（7）Map类"></a>（7）Map类</h4><p>​    1）Map类型与声明Map变量</p>
<p>​        Map 类 实现C++中的数组内存和Eigen对象的交互</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Matrix&lt;<span class="keyword">typename</span> Scalar, <span class="type">int</span> RowsAtCompileTime, <span class="type">int</span> ColsAtCompileTime&gt; &gt;</span><br></pre></td></tr></table></figure>
<p>​    在这种默认情况下，Map仅需要一个模板参数。</p>
<p>​    要构造Map变量，还需要其他两条信息：指向定义系数数组的内存区域的指针，以及所需的矩阵或矢量形状。(注意区分模板参数和函数形参)</p>
<p>​    例如，要定义一个float在编译时确定大小的矩阵，您可以执行以下操作：<code>Map &lt;MatrixXf&gt; mf(pf，rows，columns);</code>其中pf是一个float类型的指针，指向内存中的数组。固定大小的整数只读向量可能会声明为<code>Map &lt;const Vector4i&gt; mi(pi);</code>其中pi是int *。在这种情况下，不必将大小传递给构造函数，因为它已经由Matrix / Array类型指定。</p>
<p>​    Map足够灵活，可以容纳各种不同的数据表示形式。还有其他两个（可选）模板参数：<code>Map&lt;typename MatrixType, int MapOptions,typename StrideType&gt;</code>，MapOptions指定指针是Aligned还是Unaligned。默认值为Unaligned。StrideType允许使用Stride类为内存阵列指定自定义布局。一个示例是指定数据数组以行优先格式进行组织MapConstruct()。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) array[i] = i;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Column-major:\n&quot;</span> &lt;&lt; Map&lt;Matrix&lt;<span class="type">int</span>,<span class="number">2</span>,<span class="number">4</span>&gt;&gt;(array) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Row-major:\n&quot;</span> &lt;&lt; Map&lt;Matrix&lt;<span class="type">int</span>,<span class="number">2</span>,<span class="number">4</span>,RowMajor&gt;&gt;(array) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Row-major using stride:\n&quot;</span> </span><br><span class="line">	 &lt;&lt;  Map&lt;Matrix&lt;<span class="type">int</span>,<span class="number">2</span>,<span class="number">4</span>&gt;, Unaligned, Stride&lt;<span class="number">1</span>,<span class="number">4</span>&gt;&gt;(array) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>​    2）使用Map参数</p>
<p>​    有点复杂了。。。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Matrix&lt;<span class="type">float</span>,<span class="number">1</span>,Dynamic&gt; MatrixType;</span><br><span class="line"><span class="keyword">typedef</span> Map&lt;MatrixType&gt; MapType;</span><br><span class="line"><span class="keyword">typedef</span> Map&lt;<span class="type">const</span> MatrixType&gt; MapTypeConst;   <span class="comment">// a read-only map</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n_dims = <span class="number">5</span>;</span><br><span class="line">  </span><br><span class="line"><span class="function">MatrixType <span class="title">m1</span><span class="params">(n_dims)</span>, <span class="title">m2</span><span class="params">(n_dims)</span></span>;</span><br><span class="line">m1.<span class="built_in">setRandom</span>();</span><br><span class="line">m2.<span class="built_in">setRandom</span>();</span><br><span class="line"><span class="type">float</span> *p = &amp;<span class="built_in">m2</span>(<span class="number">0</span>);  <span class="comment">// get the address storing the data for m2</span></span><br><span class="line"><span class="function">MapType <span class="title">m2map</span><span class="params">(p,m2.size())</span></span>;   <span class="comment">// m2map shares data with m2</span></span><br><span class="line"><span class="function">MapTypeConst <span class="title">m2mapconst</span><span class="params">(p,m2.size())</span></span>;  <span class="comment">// a read-only accessor for m2</span></span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m1: &quot;</span> &lt;&lt; m1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m2: &quot;</span> &lt;&lt; m2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Squared euclidean distance: &quot;</span> &lt;&lt; (m1-m2).<span class="built_in">squaredNorm</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Squared euclidean distance, using map: &quot;</span> &lt;&lt;</span><br><span class="line">  (m1-m2map).<span class="built_in">squaredNorm</span>() &lt;&lt; endl;</span><br><span class="line"><span class="built_in">m2map</span>(<span class="number">3</span>) = <span class="number">7</span>;   <span class="comment">// this will change m2, since they share the same array</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Updated m2: &quot;</span> &lt;&lt; m2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m2 coefficient 2, constant accessor: &quot;</span> &lt;&lt; <span class="built_in">m2mapconst</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"><span class="comment">/* m2mapconst(2) = 5; */</span>   <span class="comment">// this yields a compile-time error</span></span><br></pre></td></tr></table></figure>
<h4 id="（8）对齐问题"><a href="#（8）对齐问题" class="headerlink" title="（8）对齐问题"></a>（8）对齐问题</h4><p>​    1）对齐错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Eigen::internal::matrix_array&lt;T, Size, MatrixOptions, Align&gt;::internal::matrix_array()</span><br><span class="line">[with T = double, int Size = 2, int MatrixOptions = 2, bool Align = true]:</span><br><span class="line">Assertion `(reinterpret_cast&lt;size_t&gt;(array) &amp; (sizemask)) == 0 &amp;&amp; &quot;this assertion</span><br><span class="line">is explained here: http://eigen.tuxfamily.org/dox-devel/group__TopicUnalignedArrayAssert.html</span><br><span class="line">READ THIS WEB PAGE !!! ****&quot;&#x27; failed.</span><br></pre></td></tr></table></figure>
<p>​    2）四种原因</p>
<p>​    <strong>原因1:结构体中具有Eigen对象成员</strong></p>
<p>​    注意，此处Eigen :: Vector2d仅用作示例，更一般而言，所有固定大小的可矢量化Eigen类型都会出现此问题，固定大小的可矢量化Eigen类型是如果它具有固定的大小并且大小是16字节的倍数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Vector2d</span><br><span class="line">Eigen::Vector4d</span><br><span class="line">Eigen::Vector4f</span><br><span class="line">Eigen::Matrix2d</span><br><span class="line">Eigen::Matrix2f</span><br><span class="line">Eigen::Matrix4d</span><br><span class="line">Eigen::Matrix4f</span><br><span class="line">Eigen::Affine3d</span><br><span class="line">Eigen::Affine3f</span><br><span class="line">Eigen::Quaterniond</span><br><span class="line">Eigen::Quaternionf</span><br></pre></td></tr></table></figure>
<p>​    首先, “固定大小”应该清楚：如果在编译时，Eigen对象的行数和列数是固定的，则其固定大小。因此，例如Matrix3f具有固定大小，但MatrixXf没有（固定大小的对立是动态大小）。固定大小的Eigen对象的系数数组是普通的“静态数组”，不会动态分配。例如，Matrix4f后面的数据只是一个“float array[16]”。固定大小的对象通常很小，这意味着我们要以零的运行时开销（在内存使用和速度方面）来处理它们。现在，矢量化（SSE和AltiVec）都可以处理128位数据包。此外，出于性能原因，这些数据包必须具有128位对齐。因此，事实证明，固定大小的Eigen对象可以向量化的唯一方法是，如果它们的大小是128位或16个字节的倍数。然后，Eigen将为这些对象请求16字节对齐，并且此后将依赖于这些对象进行对齐，因此不会执行运行时检查以进行对齐。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  Eigen::Vector2d v;</span><br><span class="line">  ...</span><br><span class="line">&#125;; </span><br><span class="line">...</span><br><span class="line">Foo *foo = <span class="keyword">new</span> Foo;</span><br></pre></td></tr></table></figure>
<p>​    Eigen需要Eigen :: Vector2d的数组（2个双精度）的128位对齐。对于GCC，这是通过属性（（aligned（16）））完成的。Eigen重载了Eigen :: Vector2d的“ operator new”，因此它将始终返回128位对齐的指针。因此，通常情况下，您不必担心任何事情，Eigen会为您处理对齐。</p>
<p>​    除了一种情况。当您具有上述的Foo类，并且如上所述动态分配新的Foo时，则由于Foo没有对齐“ operator new”，因此返回的指针foo不一定是128位对齐的。然后，成员v的alignment属性相对于类的开头foo。如果foo指针未对齐，则foo-&gt; v也不会对齐！解决方案是让Foo类具有一致的“Operator new”</p>
<p>​    <strong>解决方法：</strong></p>
<p>​    如果定义的结构具有固定大小的可矢量化Eigen类型的成员，则必须重载其“ operator new”，以便它生成16字节对齐的指针。幸运的是，Eigen提供了一个宏<code>EIGEN_MAKE_ALIGNED_OPERATOR_NEW</code>来执行此操作。换句话说：有一个类，该类具有固定大小的可矢量化Eigen对象作为成员，然后动态创建该类的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  Eigen::Vector4d v;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//... </span></span><br><span class="line">Foo *foo = <span class="keyword">new</span> Foo;</span><br></pre></td></tr></table></figure>
<p>​    该宏使“ new Foo”始终返回对齐的指针。一个 Eigen::Vector2d有两个double类型，一个double为8字节=64位，则一个Eigen::Vector2d为128位，这恰好是SSE数据包的大小，这使得可以使用SSE对该向量执行各种操作。但是SSE指令（至少Eigen使用的是快速指令）需要128位对齐。否则会出现段错误。</p>
<p>​    原因2：STL容器或手动内存分配</p>
<p>​    原因3：通过值传递Eigen对象</p>
<p>​    原因4:编译器对堆栈对齐做出错误假设（例如Windows上的GCC）</p>
<p>此章节中还有少部分未写：Reshape，Slicing and Indexing，Aliasing，Storage orders，一是用不到，二是感觉今后的矩阵运算基本上都是线性代数的内容，出错率较低，错了之后再查也是可以的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">风吹花舞う</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/09/26/%E3%80%90Eigen%E3%80%91Chapter1%20%E7%9F%A9%E9%98%B5%E5%92%8C%E6%95%B0%E7%BB%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">http://example.com/2022/09/26/【Eigen】Chapter1 矩阵和数组基本操作/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">风吹花舞う</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%9F%A9%E9%98%B5/">矩阵</a></div><div class="post_share"><div class="social-share" data-image="/img/sakura.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/26/%E3%80%90Eigen%E3%80%91Chapter2%20%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3%E4%B8%8E%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/"><img class="prev-cover" src="/img/sakura.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【Eigen】Chapter2 Chapter2 线性方程组求解与矩阵分解 Dense Linear Problems and Decompositions</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/26/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"><img class="next-cover" src="/img/sakura.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">我的第一篇博客</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/09/26/%E3%80%90Eigen%E3%80%91Chapter2%20%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3%E4%B8%8E%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/" title="【Eigen】Chapter2 Chapter2 线性方程组求解与矩阵分解 Dense Linear Problems and Decompositions"><img class="cover" src="/img/sakura.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-26</div><div class="title">【Eigen】Chapter2 Chapter2 线性方程组求解与矩阵分解 Dense Linear Problems and Decompositions</div></div></a></div><div><a href="/2022/09/26/%E3%80%90Eigen%E3%80%91Chapter4%20%E5%87%A0%E4%BD%95%E6%A8%A1%E5%9D%97/" title="【Eigen】Chapter4 几何模块 Geometry"><img class="cover" src="/img/sakura.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-26</div><div class="title">【Eigen】Chapter4 几何模块 Geometry</div></div></a></div><div><a href="/2022/09/26/%E3%80%90Eigen%E3%80%91Chapter3%20%E7%A8%80%E7%96%8F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" title="【Eigen】Chapter3 稀疏线性代数 Sparse Linear Algebra"><img class="cover" src="/img/sakura.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-26</div><div class="title">【Eigen】Chapter3 稀疏线性代数 Sparse Linear Algebra</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/rokisi.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">风吹花舞う</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/SLAM/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/konan6915"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/konan6915" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://space.bilibili.com/67074857" target="_blank" title="Bilibili"><i class="fas fa-film"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">我的个人博客，欢迎收藏网站 ^-^</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%880%EF%BC%89%E6%A8%A1%E5%9D%97%E5%92%8C%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text">（0）模块和头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%9F%A9%E9%98%B5%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">（1）矩阵类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%9F%A9%E9%98%B5%E4%B8%8E%E5%90%91%E9%87%8F%E8%BF%90%E7%AE%97"><span class="toc-number">3.</span> <span class="toc-text">（2）矩阵与向量运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89Array%E7%B1%BB%E4%B8%8E%E7%B3%BB%E6%95%B0%E6%93%8D%E4%BD%9C"><span class="toc-number">4.</span> <span class="toc-text">（3）Array类与系数操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%9D%97%E6%93%8D%E4%BD%9C"><span class="toc-number">5.</span> <span class="toc-text">（4）块操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E9%AB%98%E7%BA%A7%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">（5）高级初始化方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E5%BD%92%E7%BA%A6%EF%BC%8C%E8%AE%BF%E9%97%AE%E8%80%85%E5%92%8C%E5%B9%BF%E6%92%AD"><span class="toc-number">7.</span> <span class="toc-text">（6）归约，访问者和广播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%887%EF%BC%89Map%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">（7）Map类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%888%EF%BC%89%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98"><span class="toc-number">9.</span> <span class="toc-text">（8）对齐问题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/10/21/G2O/" title="【g2o】g2o学习笔记1"><img src="/img/sakura.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【g2o】g2o学习笔记1"/></a><div class="content"><a class="title" href="/2022/10/21/G2O/" title="【g2o】g2o学习笔记1">【g2o】g2o学习笔记1</a><time datetime="2022-10-21T10:13:34.000Z" title="发表于 2022-10-21 18:13:34">2022-10-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/21/Ceres/" title="【Ceres】Ceres学习笔记1"><img src="/img/sakura.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Ceres】Ceres学习笔记1"/></a><div class="content"><a class="title" href="/2022/10/21/Ceres/" title="【Ceres】Ceres学习笔记1">【Ceres】Ceres学习笔记1</a><time datetime="2022-10-21T10:12:01.000Z" title="发表于 2022-10-21 18:12:01">2022-10-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/21/%E3%80%90OpenCV%E3%80%91OpenCV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/" title="【OpenCV】OpenCV学习笔记1"><img src="/img/sakura.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【OpenCV】OpenCV学习笔记1"/></a><div class="content"><a class="title" href="/2022/10/21/%E3%80%90OpenCV%E3%80%91OpenCV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/" title="【OpenCV】OpenCV学习笔记1">【OpenCV】OpenCV学习笔记1</a><time datetime="2022-10-21T10:11:01.000Z" title="发表于 2022-10-21 18:11:01">2022-10-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/30/%E3%80%90VIO%E3%80%91%E7%BB%83%E4%B9%A01%20IMU%E6%A0%87%E5%AE%9A/" title="【VIO】练习1 IMU标定"><img src="/img/sakura.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【VIO】练习1 IMU标定"/></a><div class="content"><a class="title" href="/2022/09/30/%E3%80%90VIO%E3%80%91%E7%BB%83%E4%B9%A01%20IMU%E6%A0%87%E5%AE%9A/" title="【VIO】练习1 IMU标定">【VIO】练习1 IMU标定</a><time datetime="2022-09-30T12:25:30.000Z" title="发表于 2022-09-30 20:25:30">2022-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/30/%E3%80%90VIO%E3%80%91%E7%AC%AC1%E8%AE%B2%20IMU%20%E4%BC%A0%E6%84%9F%E5%99%A8/" title="【VIO】第1讲 IMU 传感器"><img src="/img/sakura.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【VIO】第1讲 IMU 传感器"/></a><div class="content"><a class="title" href="/2022/09/30/%E3%80%90VIO%E3%80%91%E7%AC%AC1%E8%AE%B2%20IMU%20%E4%BC%A0%E6%84%9F%E5%99%A8/" title="【VIO】第1讲 IMU 传感器">【VIO】第1讲 IMU 传感器</a><time datetime="2022-09-30T12:20:34.000Z" title="发表于 2022-09-30 20:20:34">2022-09-30</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/sakura.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By 风吹花舞う</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>